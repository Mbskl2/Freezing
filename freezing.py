# -*- coding: utf-8 -*-
"""probyZwarstwami.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18Mj2XYJ6GiDPYbiZ1jGp1QWsfYb7YSE2
"""

!pip install tensorflow-gpu

import tensorflow as tf
print(tf.__version__)
print(tf.keras.__version__)
tf.test.gpu_device_name() # is GPU working

"""TODO:


1.   Dodać obsługę wymrażania co epokę, co batch itd.
2.   Dodać możliwość wymrażania co kilka epoko itp.
3.   Dodać obsługę warstw konwolucyjnych.


"""

import numpy as np

class FreezingLayer(tf.keras.layers.Layer):
  def __init__(self, frozen_percentage, layer):
    super().__init__()
    self.layer = layer
    self.frozen_percentage = frozen_percentage

  def build(self, input_shape):
    self.layer.build(input_shape)   

  def compute_output_shape(self, input_shape):
    return self.layer.compute_output_shape(input_shape)

  def call(self, input):
    return self.layer.call(input)

  def get_config(self):
    return self.layer.get_config()

  def save_weights(self):
    self.__validate_layer(self.layer)
    layer_weights = self.layer.get_weights()[0]
    self.mask = self.__create_mask(layer_weights)
    self.old_weights = layer_weights[self.mask]

  def reset_weights(self):
    self.__set_weights_on_layer(self.layer, self.old_weights, self.mask)

  def __validate_layer(self, layer):
    assert len(layer.get_weights()) > 0, "Cannot freeze layers that don't have weights."
    assert len(layer.get_weights()[0].shape) == 2, 'FreezingLayer is applicable only for layers with matrices of weights with 2 dimensions e.g not Convolutional layers.'

  def __create_mask(self, layer):
    frozen_neurons = np.random.rand(layer.shape[0]) < self.frozen_percentage 
    mask = np.full(layer.shape, False)
    mask[frozen_neurons, :] = True
    return mask
      
  def __set_weights_on_layer(self, layer, old_weights, mask):
    weights = layer.get_weights()
    weights[0][mask] = old_weights
    layer.set_weights(weights)

class EnableFreezing(tf.keras.callbacks.Callback):
  def save_weights(self):
    for layer in self.model.layers:
      if isinstance(layer, FreezingLayer):
        layer.save_weights()

  def reset_weights(self):
    for layer in self.model.layers:
      if isinstance(layer, FreezingLayer):
        layer.reset_weights()

class EnableFreezingEveryNBatches(EnableFreezing):
  def __init__(self, N = 1):
    self.N = N

  def on_train_batch_begin(self, batch, logs=None):
    if batch % self.N == 0:
      self.save_weights()

  def on_train_batch_end(self, batch, logs=None):
    if batch % self.N == 0:
      self.reset_weights()

class EnableFreezingEveryNEpochs(EnableFreezing):
  def __init__(self, N = 1):
    self.N = N

  def on_epoch_begin(self, epoch, logs=None):
    if epoch % self.N == 0:
      self.save_weights()

  def on_epoch_end(self, epoch, logs=None):
    if epoch % self.N == 0:
      self.reset_weights()

from tensorflow.keras.datasets import cifar10
from tensorflow.keras import utils
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D

num_classes = 10
num_epochs = 2

(x_train, y_train), (x_test, y_test) = cifar10.load_data()
x_train = x_train.astype('float32') / 255
x_test = x_test.astype('float32') / 255

y_train = tf.keras.utils.to_categorical(y_train, num_classes)
y_test = tf.keras.utils.to_categorical(y_test, num_classes)

# x_train.shape #(50000, 32, 32, 3)
# y_train.shape #(50000, 10)
# x_test.shape  #(10000, 32, 32, 3)
# y_test.shape  #(10000, 10)

model = Sequential()
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3), kernel_initializer='he_uniform')) # With 'glorot' conv layers sometimes don't learn
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Flatten())
model.add(FreezingLayer(1.0, Dense(150, activation='relu')))
# model.add(Dense(150, activation='relu'))
model.add(FreezingLayer(1.0, Dense(120, activation='relu')))
# model.add(Dense(120, activation='relu'))
model.add(FreezingLayer(1.0, Dense(num_classes, activation='softmax')))

model.compile(loss=tf.keras.losses.categorical_crossentropy,
                    optimizer=tf.keras.optimizers.Adam(),
                    metrics=['accuracy'])

model.fit(x_train, y_train, batch_size=32, epochs=5, callbacks=[EnableFreezingEveryNEpochs()]) 
train_score = model.evaluate(x_train, y_train, verbose=0)
test_score = model.evaluate(x_test, y_test, verbose=0)

print(train_score, test_score)